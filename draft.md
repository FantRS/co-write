# Загальний план реалізації

## 1. Архітектура проєкту

* **Frontend**

- Авторизація (JWT + localStorage/cookies).
- Інтерфейс для редагування тексту.
- Підключення до сервера через WebSocket для отримання/відправлення змін.
  - Рендеринг стану документа на основі поточної CRDT-моделі.

* **Backend (actix_web)**

  - REST API для авторизації, створення та відкриття документів.
  - WebSocket сервер для обміну змінами.
  - CRDT-модель в пам'яті для активних документів.
  - Event log + snapshot в PostgreSQL.

* **DB (PostgreSQL)**

  - Таблиця `documents` для зберігання стану (snapshot).

```
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    title TEXT NOT NULL,
    state BYTEA NOT NULL,
    updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```

  - Таблиця `document_updates` для зберігання логів змін.
  
```
CREATE TABLE document_updates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    document_id UUID NOT NULL REFERENCES documents(id) ON DELETE CASCADE,
    update BYTEA NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```



## 2. Потік роботи з документом

1. Користувач відкриває документ → клієнт робить **REST запит**, отримує snapshot стану.
2. Клієнт підключається по **WebSocket** → починає отримувати всі нові зміни.
3. Коли користувач вносить зміни → вони відправляються на сервер (WebSocket повідомлення).
4. Сервер застосовує зміни до CRDT-моделі в пам'яті і:
  - розсилає їх всім іншим учасникам,
  - зберігає update в `document_updates`.
5. Періодично або за подією (наприклад, закриття документа) сервер робить snapshot в `documents.state`.



# Основні завдання

## 1. Авторизація

* API реєстрації/логіну (actix-web + sqlx).
* Зберігання паролів через bcrypt.
* Видача JWT-токенів.

> [! NOTE]
> Користувач при вході отримує JWT → відправляє його в заголовках до REST і при з'єднанні WebSocket. Сервер валідує токен.



## 2. Робота з документом (REST API)

* `POST /documents` → створити документ.
* `GET /documents/{id}` → повернути snapshot документа.
* `GET /documents/{id}/updates?since=...` → повернути лог змін (для відновлення при reconnect).

> [! NOTE]
> snapshot зберігається в `documents.state` (серіалізований CRDT).
> логи зберігаються в `document_updates`.
> при reconnect клієнт може отримати всі зміни, яких у нього немає.



## 3. WebSocket + CRDT синхронізація

* Підняти WebSocket endpoint `/ws/{document_id}`.
* Клієнт відправляє операції у форматі CRDT update.
* Сервер застосовує update до документа в пам'яті, розсилає іншим.

> [! NOTE]
> CRDT забезпечує унікальні ідентифікатори для кожного символу.
> При вставці двох символів в одне місце → порядок визначається їх ID (за часом + випадковий компонент).
> При видаленні сервер просто позначає символ як «видалений» (але зберігає ID для консистентності).
> Таким чином, конфліктів «чий символ залишився» не виникає.



## 4. Зберігання стану

* Підтримувати документ у пам'яті (модель CRDT).
* Логувати зміни в `document_updates`.
* Періодично зберігати snapshot в `documents.state`.

> [! NOTE]
> При запуску редагування сервер піднімає модель CRDT зі snapshot + логів.
> Всі нові зміни записуються і в пам'ять, і в базу.
> Snapshot потрібен для швидкого завантаження (щоб не накочувати 10k змін кожен раз).



## 5. Обробка помилок і відмовостійкість

* Якщо клієнт відключився → при reconnect він відправляє `last_known_update_id`.
* Сервер повертає всі зміни після цього ID.
* Якщо сервер падає → після рестарту CRDT відновлюється з snapshot + останніх змін.

> [! NOTE] 
> Такий підхід гарантує, що ніхто не втратить дані, навіть якщо сервер «впав» прямо в момент редагування.



# План завдань по кроках

1. **Базовий бекенд**

 * Налаштувати actix_web + sqlx.
 * Зробити авторизацію (реєстрація, вхід, JWT).

2. **База даних**

 * Створити таблиці `documents`, `document_updates`.
 * CRUD для документів.

3. **WebSocket шар**

 * Реалізувати підключення до `/ws/{document_id}`.
 * Налаштувати аутентифікацію по JWT при підключенні.

4. **CRDT модель**

 * Підключити бібліотеку CRDT.
 * Налаштувати серіалізацію/десеріалізацію стану.
 * Навчитися застосовувати зміни і розсилати їх.

5. **Frontend**

 * Авторизація.
 * Інтерфейс з редактором (наприклад, CodeMirror з CRDT адаптером).
 * Підключення по WebSocket і оновлення стану редактора.

6. **Збереження стану**

 * При кожній зміні → лог в `document_updates`.
 * Snapshot в `documents.state` раз в N секунд або при закритті документа.

7. **Реалізація відновлення**

 * При reconnect клієнт повідомляє `last_update_id`.
 * Сервер віддає відсутні updates.