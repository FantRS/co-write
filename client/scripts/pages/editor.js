import { showToast } from "../other/showToast.js";
import { webSocketUrl } from "../core/paths.js";

console.log("editor.js module loaded");

class Editor {
    constructor() {
        console.log("Editor constructor called");
        this.socket = null;
        this.doc = null;
        this.syncState = null;
        this.isLocalChange = false;
        this.Automerge = null;
        
        this.initializeElements();
        this.initializeEventListeners();
        this.loadAutomerge();
        console.log("Editor initialized successfully");
    }

    // == LOAD AUTOMERGE ASYNCHRONOUSLY ==
    async loadAutomerge() {
        try {
            console.log("Loading Automerge...");
            const AutomergeModule = await import("@automerge/automerge");
            this.Automerge = AutomergeModule;
            console.log("Automerge loaded successfully", Object.keys(AutomergeModule));
            
            this.initializeAutomerge();
            this.setupWebSocket();
        } catch (error) {
            console.error("Failed to load Automerge:", error);
            showToast("–ü–æ–º–∏–ª–∫–∞ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è Automerge: " + error.message);
        }
    }

    // == INIT AUTOMERGE DOCUMENT ==
    initializeAutomerge() {
        try {
            console.log("Initializing Automerge document...");
            // Create a new Automerge document with a text field
            this.doc = this.Automerge.from({
                content: ""
            });
            
            // Initialize sync state
            this.syncState = this.Automerge.initSyncState();
            
            console.log("Automerge initialized", this.doc);
        } catch (error) {
            console.error("Error initializing Automerge:", error);
            showToast("–ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó –¥–æ–∫—É–º–µ–Ω—Ç–∞");
        }
    }

    // == INIT ELEMENTS BY ID ==
    initializeElements() {
        console.log("Initializing elements...");
        this.editorArea = document.getElementById("editorArea");
        this.documentTitle = document.getElementById("documentTitle");
        this.connectionStatus = document.getElementById("connectionStatus");
        this.connectedUsers = document.getElementById("connectedUsers");
        this.syncStatus = document.getElementById("syncStatus");
        this.copyLinkBtn = document.getElementById("copyLink");
        this.backToLobbyBtn = document.getElementById("backToLobby");
        this.toast = document.getElementById("toast");

        console.log("Elements found:", {
            editorArea: !!this.editorArea,
            copyLinkBtn: !!this.copyLinkBtn,
            backToLobbyBtn: !!this.backToLobbyBtn
        });

        // Get document ID from URL
        this.documentId = new URL(window.location.href).searchParams.get("id");
        console.log("Document ID:", this.documentId);
        
        if (!this.documentId) {
            showToast("–î–æ–∫—É–º–µ–Ω—Ç –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ", 3000);
            setTimeout(() => {
                window.location.href = "/";
            }, 3000);
        }
    }

    // == INIT EVENT LISTENERS ==
    initializeEventListeners() {
        console.log("Setting up event listeners...");
        
        if (this.editorArea) {
            this.editorArea.addEventListener("input", () => {
                this.handleTextareaInput();
            });
            console.log("‚úì Editor area listener added");
        }

        if (this.copyLinkBtn) {
            this.copyLinkBtn.addEventListener("click", () => {
                console.log("Copy link button clicked");
                const url = window.location.href;
                navigator.clipboard
                    .writeText(url)
                    .then(() => showToast("–ü–æ—Å–∏–ª–∞–Ω–Ω—è —Å–∫–æ–ø—ñ–π–æ–≤–∞–Ω–æ"))
                    .catch(() => showToast("–ü–æ–º–∏–ª–∫–∞ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è –ø–æ—Å–∏–ª–∞–Ω–Ω—è"));
            });
            console.log("‚úì Copy link listener added");
        }

        if (this.backToLobbyBtn) {
            this.backToLobbyBtn.addEventListener("click", () => {
                console.log("Back to lobby button clicked");
                window.location.href = "/client/index.html";
            });
            console.log("‚úì Back to lobby listener added");
        }

        window.addEventListener("beforeunload", () => {
            if (this.socket) {
                this.socket.close();
            }
        });
        
        console.log("All event listeners initialized");
    }

    // == SETUP WEBSOCKET LISTENERS ==
    setupWebSocket() {
        if (!this.Automerge) {
            console.error("Cannot setup WebSocket: Automerge not loaded");
            return;
        }

        console.log("Setting up WebSocket...");
        this.socket = new WebSocket(webSocketUrl(this.documentId));
        this.socket.binaryType = "arraybuffer";

        console.log("Connecting to:", webSocketUrl(this.documentId));

        this.socket.onopen = () => {
            console.log("‚úì WebSocket connected");
            console.log("üì° Ready to sync with other clients in room:", this.documentId);
            this.updateConnectionStatus("connected");
            showToast("–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ —Å–µ—Ä–≤–µ—Ä–∞");
            this.sendSyncMessage();
        };

        this.socket.onclose = () => {
            console.log("‚úó WebSocket closed");
            this.updateConnectionStatus("disconnected");
            showToast("–í—Ç—Ä–∞—á–µ–Ω–æ –∑'—î–¥–Ω–∞–Ω–Ω—è –∑ —Å–µ—Ä–≤–µ—Ä–æ–º");

            setTimeout(() => {
                this.setupWebSocket();
            }, 5000);
        };

        this.socket.onerror = (error) => {
            console.error("‚úó WebSocket error:", error);
            this.updateConnectionStatus("error");
            showToast("–ü–æ–º–∏–ª–∫–∞ –∑'—î–¥–Ω–∞–Ω–Ω—è –∑ —Å–µ—Ä–≤–µ—Ä–æ–º");
        };

        this.socket.onmessage = (event) => {
            console.log("‚Üê WebSocket message received", typeof event.data);
            if (event.data instanceof ArrayBuffer) {
                this.handleBinarySyncMessage(event.data);
            } else {
                try {
                    const data = JSON.parse(event.data);
                    this.handleJsonMessage(data);
                } catch (e) {
                    console.error("Failed to parse message:", e);
                }
            }
        };
    }

    // == HANDLE BINARY SYNC MESSAGES ==
    handleBinarySyncMessage(arrayBuffer) {
        try {
            const message = new Uint8Array(arrayBuffer);
            console.log("üì• Received binary sync message from another client, length:", message.length);
            
            const [newDoc, newSyncState, patch] = this.Automerge.receiveSyncMessage(
                this.doc,
                this.syncState,
                message
            );

            if (newDoc) {
                this.doc = newDoc;
                this.syncState = newSyncState;
                console.log("‚úì Document updated from remote client, patches:", patch?.length || 0);
                console.log("üìÑ New document content:", this.doc.content);
                
                if (patch && patch.length > 0) {
                    this.updateTextareaFromDoc();
                    this.updateSyncStatus("–û—Ç—Ä–∏–º–∞–Ω–æ –∑–º—ñ–Ω–∏ –≤—ñ–¥ —ñ–Ω—à–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞");
                    setTimeout(() => {
                        this.updateSyncStatus("–°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–æ–≤–∞–Ω–æ");
                    }, 2000);
                }
                
                this.sendSyncMessage();
            } else if (newSyncState) {
                this.syncState = newSyncState;
                console.log("‚úì Sync state updated (no doc changes)");
            }
        } catch (error) {
            console.error("‚úó Error handling sync message:", error);
            showToast("–ü–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó");
        }
    }

    // == HANDLE JSON MESSAGES ==
    handleJsonMessage(data) {
        console.log("‚Üê Handling JSON message", data);
        
        // Server sends { status: 200, message: "Ok" } as acknowledgment
        if (data.status === 200) {
            console.log("‚úì Server acknowledged sync message");
            return;
        }
        
        switch (data.type) {
            case "users":
                this.updateConnectedUsers(data.count);
                break;
            case "error":
                showToast(data.message);
                break;
            default:
                console.log("Unknown message type:", data.type, data);
        }
    }

    // == SEND SYNC MESSAGE ==
    sendSyncMessage() {
        if (!this.socket || this.socket.readyState !== WebSocket.OPEN) {
            console.log("‚úó Cannot send sync message, socket not ready");
            return;
        }

        if (!this.Automerge) {
            console.log("‚úó Cannot send sync message, Automerge not loaded");
            return;
        }

        try {
            const [nextSyncState, syncMessage] = this.Automerge.generateSyncMessage(
                this.doc,
                this.syncState
            );

            if (syncMessage) {
                this.syncState = nextSyncState;
                console.log("‚Üí Sending sync message, length:", syncMessage.length);
                this.socket.send(syncMessage);
            } else {
                console.log("‚óã No sync message to send");
            }
        } catch (error) {
            console.error("‚úó Error sending sync message:", error);
        }
    }

    // == HANDLE TEXTAREA INPUT ==
    handleTextareaInput() {
        if (this.isLocalChange) {
            console.log("‚óã Skipping input (local change)");
            return;
        }

        if (!this.Automerge) {
            console.log("‚úó Cannot handle input: Automerge not loaded");
            return;
        }

        console.log("‚úé Handling textarea input");
        this.updateSyncStatus("–°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è...");

        try {
            const textareaContent = this.editorArea.value;
            const docContent = this.doc.content || "";

            this.applyTextChanges(docContent, textareaContent);
            this.sendSyncMessage();
            this.updateSyncStatus("–°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–æ–≤–∞–Ω–æ");
        } catch (error) {
            console.error("‚úó Error syncing content:", error);
            this.updateSyncStatus("–ü–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó");
        }
    }

    // == APPLY TEXT CHANGES TO AUTOMERGE DOC ==
    applyTextChanges(oldText, newText) {
        console.log("‚úé Applying text changes");
        this.doc = this.Automerge.change(this.doc, (doc) => {
            doc.content = newText;
        });
        console.log("‚úì Document content updated");
    }

    // == UPDATE TEXTAREA FROM AUTOMERGE DOC ==
    updateTextareaFromDoc() {
        this.isLocalChange = true;

        try {
            const newContent = this.doc.content || "";
            console.log("‚Üê Updating textarea from doc, length:", newContent.length);
            
            if (this.editorArea.value !== newContent) {
                const start = this.editorArea.selectionStart;
                const end = this.editorArea.selectionEnd;

                this.editorArea.value = newContent;

                const newLength = newContent.length;
                const newStart = Math.min(start, newLength);
                const newEnd = Math.min(end, newLength);
                this.editorArea.setSelectionRange(newStart, newEnd);
                
                console.log("‚úì Textarea updated");
            }
        } finally {
            this.isLocalChange = false;
        }
    }

    // == UPDATE INFO ==
    updateConnectionStatus(status) {
        if (!this.connectionStatus) return;
        
        this.connectionStatus.className = "status-chip connection-status " + status;
        const statusText = this.connectionStatus.querySelector(".status-text");
        if (!statusText) return;
        
        switch (status) {
            case "connected":
                statusText.textContent = "–ü—ñ–¥–∫–ª—é—á–µ–Ω–æ";
                break;
            case "disconnected":
                statusText.textContent = "–í—ñ–¥–∫–ª—é—á–µ–Ω–æ";
                break;
            case "connecting":
                statusText.textContent = "–ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è...";
                break;
        }
    }

    updateConnectedUsers(count) {
        if (!this.connectedUsers) return;
        const statusText = this.connectedUsers.querySelector(".status-text");
        if (statusText) {
            statusText.textContent = `–ö–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –æ–Ω–ª–∞–π–Ω: ${count}`;
        }
    }

    updateSyncStatus(status) {
        if (!this.syncStatus) return;
        const statusText = this.syncStatus.querySelector(".status-text");
        if (statusText) {
            statusText.textContent = status;
        }
    }
}

// Initialize editor when DOM is loaded
document.addEventListener("DOMContentLoaded", () => {
    console.log("=== DOMContentLoaded event fired ===");
    try {
        const editor = new Editor();
        window.editor = editor; // For debugging
        console.log("=== Editor instance created successfully ===");
    } catch (error) {
        console.error("=== ERROR creating Editor instance ===");
        console.error("Error:", error);
        console.error("Stack:", error.stack);
    }
});
